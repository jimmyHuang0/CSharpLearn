字体：Helvetica Neue

新技术：
	IOC,AOP,MVC

协变、逆变的加深理解

AOP:
	使用特性实现缓存、日志、权限等切面信息。这是从框架的角度进行系统性的使用。


Delegate类没有invoke方法，该方法是从哪里继承过来的？？？

链接：Join  ???左链接???右链接

yield与迭代器的原理???


///这里应该new Type[] { }), new Expression[0]，是什么意思，进一步学习反射来确认，GetMethod的应用
MethodCallExpression method = Expression.Call(member, typeof(Int32).GetMethod("ToString", new Type[] { }), new Expression[0]);
MethodCallExpression methodEquals = Expression.Call(method, typeof(string).GetMethod("Equals", new Type[] { typeof(string) }), new Expression[]
{
   Expression.Constant("5", typeof(string))
});

DTO??? 

automapper

变量后加'?'

多线程设计模式

IQueryable

----------------------------------------------------- doing --------------------------------------------------------------


迭代器：
	--迭代器返回一个IIterator，里面包含三个成员：current、moveNext、Reset
	--foreach调用的时候，是返回一个迭代器。相当于while循环家moveNext，退出的时候reset
	--统一了不同集合的同样的访问方式
	--只要实现 IEumerator GerEnumrator()方法，就可以使用foreach
	--yield延时加载，按需获取，可以避免一次获取全部结果

	





数据结构接口：
	--IEnumerable：可以迭代访问，linq的基础，用yield，延迟查询
	--IList: 可以索引访问
	--ICollection：表示是一个集合
	--IQueryable：可生成表达式树


数据结构：
	arrayList:
		--可以保存不同类型的队列
		--这里会进行装箱，把所有类型都变味object进行保存
	List:
		--是一个数组
		--连续内存
		--查询速度快，可通过下标索引
		--内存不够的时候，增加可能需要移动一块内存，这里会耗时
	LinkedList：
		--链表
		--插入删除效率高
	Queue:
		--队列，也是一个链表		
	Stack：
		--栈
	Dictionary：
		--泛型的hashtable
		--线程安全的用：concurrentDictionary
		--空间换时间




----------------------------------------------------- done --------------------------------------------------------------

await/async:
	--await/async 成对出现
	--返回值都是Task
	--Task可以有其他返回值
	--语法糖
	--只能await Task
	--await之后的代码相当于Task的回调函数，编译器帮忙做了这个东西



lock：
	--相当于Monitor.Enter（）
	--可以实现去掉多线程
	--查看某个引用类型的对象是否被引用，如果被引用，则等待，否则引用该对象
	--不要使用字符串当锁，因为字符串在C#里是通过享元模式实例的，相同的字符串都指向同一个内存对象
	--也不要lock(this)，外部使用的时候也会被锁定
	--可以随便定义一个object来当锁
	--如果每个实例想单独锁定，可以定义一个private object
	--推荐使用方式：
		private static readonly object btnThreadCore_Click_Lock=new object();




闭包：
	--首先，在C#里，类里面是可以定义类的
	--闭包的描述就是，函数内部可以使用其外部上下文相关的变量
	--C#的原子对象是类，也就是类里面的内部成员可以相互访问
	--闭包实质是为使用闭包的函数以及关联的变量，建了一个匿名类。把关联变量定义到匿名类中，而闭包函数则是匿名类中的一个成员函数。
		因此，成员函数就可以访问匿名类中的成员变量。
	--查看 “C#与闭包.docx” “反编译的代码.txt”



多线程取消：
	--CancellationTokenSource，可以在cancel后，取消还没有启动的线程，但是已经启动的，需要内部检查
	--线程不能由别人来取消，只能自己结束自己
	--用CancellationTokenSource，任务取消可以被waitall获取异常


多线程异常：
	--多线程的异常是不会被父线程或者程序捕捉到，这可能会引起一个很大的坑
	--如果父线程需要捕获子线程，可以使用waitall，并且子线程使用tasklist来启动。捕获到的异常是AggregateException
		catch (AggregateException aex)
            {
                foreach (var item in aex.InnerExceptions)
                {
                    Console.WriteLine(item.Message);
                }
            }
	--通常的做法是，在子线程里自己捕获异常并进行处理



Parallel：
	--相当于TaskFactory+waitAll，但是主线程也参与其中一个线程
	--API：invoke,for，foreach，




Task：
	--多线程的启用	
		--thread使用多线程，可以invoke/abort/suspend
		--threadpool基本没有暂停和杀死，建议使用回调
		--Task: 使用TaskFactory，StartNew
	--使用线程池的线程，都是后台线程
	--多线程的使用场景
		--多个启动，快点运算
		--不卡界面，后台计算
		--需要多线程加快速度，同时需要全部完成后，才能继续。
			用waitall,waitAny卡界面
			用ContinueWhenAll,ContinueWhenAny，不卡界面



委托：
	简介：
		委托的本质就是一个函数指针类型。
		函数通过指向不同函数，通过invoke来同步调用被指向的函数。
		通过BeginInvoke来进行异步调用。
	闭包域参数使用：
		在委托里，如果使用lambda函数作为调用函数，
		在lambda函数里面，可以使用被调用函数外部作用域的变量
	例子：
		定义一个委托：delegate void del(); //一般定义在类外部，作为公用的变量。
		定义一个委托变量，并给变量赋值：
			方法一：del d = new del(fun1);//fun1就是一个无参数无返回值的函数
			lambda方式：
				int ij = 1;
				//可以看出，lambda内部是可以调用ij的
				del d = new del(() => { Console.WriteLine(ij); ij = 2; Console.WriteLine(ij); });
		被调用的函数：        
			private void fun1()
	        {
	            int ij = 3;
	            Console.WriteLine(ij);
	        }


表达式目录树：
	--类：Expression
	--生成lambda表达式：Expression.Lambda<Action>(par1,par2)
	--可以自行拼装表达书目录树，动态生成lambda表达式
	--可以用来缓存


数据查询基本操作：
	--筛选：where
	--条件过滤：Select
	--排序：OrderBy
	--倒序：OrderByDescending
	--跳过：Skip
	--提取：Take
	--分组：group x by x.x into newGroup  ???如何使用多个元素分组
	--链接：Join  ???左链接???右链接


Linq to object：
	--where：用于过滤数据
		Enumerable可序列化的基类，里面有where。就是一个自定义条件的查询方法
	--yield
		--结果是一个迭代器
		--延时查询
		--yield return rst;返回结果必须是Enumerable类型
		--如果使用普通获取方式，会一次获取全部结果。
			使用yield可以实现获取中断，用多少查多少。
			这样可以减少内存的使用。
		--可以使用".ToList()"，就会立即获取全部结果
		--例子：
	      	public IEnumerable<int> yieldFun()//返回结果必须是IEnumerable<>接口
	        {
	            int i = 0;
	            while (i<10)
	            {
	                i++;
	                Thread.Sleep(1000);
	                yield return i;
	            }
	        }
	--查询运算符：
		--使用方式1：
			List<int> rList = new List<int> { 1, 2, 6, 9, 56 }.where(i => i > 5);
		--使用方式2：
			var v1 = from a in new List<int> { 1, 2, 6, 9, 56 }
					 where a > 5
					 select a;




泛型查询：(相当于Linq的where)
	--原方法：
		static class ExtendMethod
	    {
	        public static List<T> findWhere<T>(this List<T> list,Func<T,bool> predicate)
	        {
	            List<T> _list = new List<T>();
	            foreach (var item in list)
	            {
	                if (predicate.Invoke(item))
	                {
	                    _list.Add(item);
	                }
	            }
	            return _list;
	        }
	    }
	--调用： 
		List<int> rList = new List<int> { 1, 2, 6, 9, 56 }.findWhere(i => i > 5);


匿名类：
	object obj=new{ID=2} 没办法调用obj的ID属性，应为obj是object类
	dynamic dObj=new{ID=2} 编译器不做检查，在执行的时候才会检查。dynamic相当于一个字典。
	var vObj=new{ID=2} 自动类型识别，编译器给起了一个名字。这是一个语法糖。


扩展方法：
	--静态类的静态方法，一个参数类型前面加this.
	--可以在不修改类的名字和内容时，增加类的功能
	--假如原类有同名的方法，会调用原类的方法。这是一个坑！！！破坏封装性！！！
	--扩展方法不要对基础类型进行扩展，一般针对自定义的类型扩展


加密，解密：
	MD5：
		--云存储，上传检查（急速秒传，计算速度怎么样）
		--文件下载防止篡改
		--git/svn 源代码管理检查
	对称可逆加密：
		--常用算法：Des AES Blowfish
		--加秘钥和解秘钥一样
	非对称可逆：RAS
		--证明我是我：加秘钥为私钥，解秘钥为公钥。可以确保消息来源。
		--只有我能看：加秘钥为公钥，解秘钥为私钥。但是不知要消息来源。
	SSL:
		--CA机构
	Https:
		--所有过程都使用加密
		--单边认证，浏览器认证服务器，防止浏览器被DNS劫持
		--过程：（思考，在任何一个地方被劫持，是否可能存在漏洞）
			client发送请求，server返回一个CA证书。
			客户端先计算CA证书的MD5，然后，通过浏览器内置的解密公钥A，解密证书。获取一个服务器内置的另一个加密公钥B。
			客户端使用加密公钥B，加密一段文字，发送给服务器。
			服务器根据自身的解密私钥C（与加密公钥B一对）解密，并返还结果给客户端。
			客户端验证服务器返回的结果是正确的。
			客户端生成一个对称的秘钥D发送给服务器。
			服务使用对称秘钥D向客户端发送内容，进行通信。
	U盾：
		--双边认证


json:
	保存比xml小，一般用于手机的数据传输。
	出现一个格式出错，即不能解析。
	.NET使用的库一般是：NewtonSoft的json库。这个库比微软自己写的json库速度更快。
		JsonConvert.serializable()

using(){} 关键字
	语句，定义一个范围，在范围结束时处理对象。 
	当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要离开了这个代码段就自动调用这个类实例的Dispose。 
	要达到这样的目的，用try...catch来捕捉异常也是可以的，但用using也很方便


文件夹创建：
	一次性创建所有子路径：Directory.CreateDirectory(filePath)


序列化：
	序列化是将一个对象保存到存储介质上或者将对象进行转换使之能够在网络上传送的行为。
	能对一个类进行序列化的条件是：该类的任何基类可序列化；该类应用了Serializable特性。



线程池ThreadPool：
	启用：ThreadPool.QueueUserWorkItem(Action x);
	信号量：ManualResetEvent
		有两个方法：set,reset

多线程Tread：（默认属于前台线程，在父线程结束后，还会执行完再结束）
	定义方法：
		定义委托函数：TreadStart
		定义线程：Thread
		开始线程：Thread.Strat();
	设置为后台线程：
		Thread.IsBackground=true;
	任务：
		封装一个带回调的线程调用==>可以用一个委托封装两个顺序执行的委托
		封装一个带返回值的多线程调用
		关键代码：
            ///定义了一个泛型函数A，A内部启动一个线程，同时返回一个带有同类型的一个泛型函数B
            ///B是等待A线程完成后才返回一个值
            ///通过invoke B，来激活返回的泛型函数B，并最后得到返回值
            ///因此，在调用A的时候，可以做另外的东西C。但是，把 B.Invoke放在做另外的	
	        Func<T> AFun<T>(Func<T> func)
	        {

	            T t = default(T);
	            ThreadStart start = () =>
	              {
	                  t=func.Invoke();
	              };
	            Thread thread = new Thread(start);
	            thread.Start();

	            return new Func<T>(() =>
	            {
	                thread.Join();
	                return t;
	            });
	        }


获取线程ID：
	Thread.CurrentThread.ManagedThreadId


异步调用：（属于后台线程，在父线程结束后，立刻结束）
	Action<type> name =fun()...Action是只有一个参数，没有返回值的委托
	用BeginInvoke来调用异步函数

	string.ReferenceEquals
	IAsyncResult

	异步调用过程：
		先定义一个委托Delegate，并赋值一个委托的函数FunD
		使用Delegate.BeginInvoke(par,callBackFun,state)调用委托函数FunD
		FunD执行完成之后，会执行回调函数callBackFun
		也可以在Delegate.BeginInvoke，使用异步等待

	异步等待：
		方法一：while(!IAsyncResult.IsCompleted){Thread.Sleep(100);...}
		方法二，最多等待time毫秒后，继续执行：IAsyncResult.AsyncWaitHandle.WaitOne(time);
		方法三，可以获取返回值：action.EndInvoke()


类的继承：
	public和protect元素都可以被子类继承
	private元素不能被子类继承和使用


状态行为模式：statePattern
 	使用上下文context写一个状态行为模式


Attribute使用目标二：validData（在attributeDemo项目）
	定义一个枚举类型描述说明，使用扩展方法获取特性描述（静态类，定义静态方法，参数加this）
	这里使用了多态


Attribute使用目标一：（在attributeDemo项目）
	定义一个权限认证的attribute，带isLogin方法，并使用特性判断isDefined。


Attribute特性：
	定义：
		特性是一个继承Attribute的类，用于给元素做标记，在编译时，生成到meteData中。
		通过反射获取属性定义的信息，并做一些操作。
	[obsolete] ：标记使用的类或方法已经过时，编译时会warming或者error
	[serializable] ：标记可以序列化和反序列化，可以影响程序的运行
	[return : attributeA]: 给返回值增加特性
	[System.AttributeUsage(System.AttributeTargets.All,AllowMultiple = false, Inherited = true)] ：
		用于修饰特性，规定特性能修饰的地方。确定可以如何使用自定义特性类。 AttributeUsage 是一个可
		应用于自定义特性定义，以便控制如何应用新特性的特性。


Attribute的定义：
	--继承Attribute类
	--使用AttributeUsage规定特性
	--使用反射getType，或者typeof获取类型
	--使用GetCustomAttributes获取属性，没有获取单个特性的方法
	--isDefined：判断是否有某个特性
	--method.GetParameters：获取方法的参数
	--type.GetMethods：获取类型的方法
	--type.GetProperties: 获取类型的属性
	--type.GetFeilds：获取类型的字段


object类
	object 类型在 .NET Framework 中是 Object 的别名。 在 C# 的统一类型系统中，所有类型
	（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 Object 继承的。 可以
	将任何类型的值赋给 object 类型的变量。 将值类型的变量转换为对象的过程称为“装箱”。 将
	对象类型的变量转换为值类型的过程称为“取消装箱”。 有关更多信息，请参见 装箱和取消装箱。


反射的基本应用：(查看reflectionDemo)
	加载dll：
		Assembly assembly = Assembly.Load("dllName");
	获取类: 
		Type testType = assemly.GetType("Ruanmou.DB.SqlServer.ReflectionTest");
	创建实例：
		object obj=Activator.CreateInstance(testType);
	方法调用：
		获取实例的方法：MethodInfo method = instance.getMethod("methodName");
		调用重载的私有方法：
		泛型方法需要使用：makeGenericMethods
	获取属性和字段：
		获取属性：type.GetProperties()
		获取静态属性：


框架定义：
	尽量不在框架代码里面new对象，把new实际对象的工作放到实际逻辑里面做


foreach的使用：
	foreach 语句针对实现 IEnumerable 或 IEnumerable<T> 接口的数组或集合中的每个元素重复一组嵌入语句。 foreach 语句
	用于循环访问集合以获取所需信息，但不用于添加或删除源集合中的项，以避免不可预知的副作用。 如果需要添加或删除源集合中
	的项，请使用 for 循环。 为数组或集合中的每个元素继续执行嵌入的语句。 为集合中的所有元素完成迭代后，控制将传递给 foreach 
	块之后的下一语句。 在 foreach 块中的任何点上，可以使用中断关键字中断该循环，或者可以使用继续关键字单步执行到循环中的下一
	次迭代。foreach 循环还可以通过 goto、return 或 throw 语句退出。 


继承：
	子类继承了父类的所有公开方法和属性


装箱和拆箱
	装箱：在函数调用时，如果参数类型和传入的类型不一样，首先在栈中获取类型，并且在堆中外包一层并生成一个引用类型的类型。
	拆箱：把堆中生成的引用类型
	装箱和拆箱都是在C#用对object的转换操作。


系统计时：
	using System.Diagnostics
	Stopwatch stopwatch = new Stopwatch();
	stopwatch.Start();
	...
	stopwatch.Stop();
	System.Console.WriteLine("{0}",stopwatch.ElapsedMilliseconds);


泛型约束：
	基类：where T:baseClass
	接口: where T:interface
	引用类型约束：where T：class //就是这个关键字
	值类型约束：where T: struct //就是这个关键字
	无参数构造函数约束： where T:new()

	多重约束：where baseClass,itf //两个约束是and的关系


泛型缓存：
	提高性能，比用dictionary快。dic存在堆中，而缓存一般存在栈中


	

